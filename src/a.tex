% !TeX root =./x2.tex
% !TeX program = pdfpLaTeX


\chapter{数ベクトル空間での計算方法}

ここでは,
$\KK$を体とし,
$\KK$上の数ベクトル空間において,
諸々の概念を計算する方法について紹介する.

\section{\Cref{chap:prelim}に関連すること}
行列に対する以下の操作を行基本変形と呼んだ:
\begin{enumerate}
\item $i$行目を$c$倍する. (ただし, $c\neq 0$.)
\item $i$行目に$j$行目の$a$倍を加える. (ただし, $i\neq j$.)
\item $i$行目と$j$行目を入れ替える. (ただし, $i\neq j$.)
\end{enumerate}
また,
行列に対する以下の操作を列基本変形と呼んだ:
\begin{enumerate}
\item $i$列目を$c$倍する. (ただし, $c\neq 0$.)
\item $j$列目に$i$列目の$a$倍を加える. (ただし, $i\neq j$.)
\item $i$列目と$j$列目を入れ替える. (ただし, $i\neq j$.)
\end{enumerate}
これらを使ってどんな行列も行列
被役行階段行列や
被役列階段行列と呼ばれる形に変形できた.
行列に対する行基本変形や列基本変形は,
実際には行ベクトル, 列ベクトルに対する操作である.
その観点から用語や計算方法を整理する.

$I=\Set{1,\ldots,m}$とし,
$\aaa=(a_i)_{i\in I}\in \KK^m\setminus\Set{\zzero_m}$
とする.
$\min\Set{i\in I |a_i\neq 0}$
を$\aaa$のpivotもしくはleading positionと呼ぶことにし,
$\lp(\aaa)$で表す.
また,
$i_0=\lp(\aaa)$に対し,
$a_{i_0}=1$を満たしているときに,
$\aaa$はmonicであるということにする.
また$X\subset \RR^m\setminus\Set{\zzero_m}$に対し,
次の条件を満たしているとき, $\aaa=(a_i)_{i\in I}\in\RR^m$は$X$で被役であるとか簡約済みであるということにする:
\begin{align*}
  \bbb\in X, i=\lp(\bbb) \implies
  a_{i}=0.
\end{align*}
列ベクトルでも行ベクトルでも同じ用語や記号を用いることにする.

便宜的に$\lp(\zzero)=\infty$とし, 
$\zzero$もmonicであるとし,
$\infty$は$\infty<\infty$を満たすとしておくと,
$A=(\aaa_1|\cdots|\aaa_n)$と列ベクトル表示された行列が
被役列階段行列であることは, 以下のように述べることができる:
\begin{enumerate}
\item
  $j\in\Set{1,\ldots,n}\implies \aaa_j$はmonic.
\item
  $j\in\Set{1,\ldots, n-1} \implies \lp(\aaa_j)<\lp(\aaa_{j+1})$.
\item
  $j\in\Set{1,\ldots, n}, j'\in \Set{1,\ldots, n}\setminus\Set{j}\implies \lp(\aaa_{j'})=\infty$
  または$\aaa_j$の$\lp(\aaa_{j'})$-成分は$0$.
\end{enumerate}
被役列階段行列$A=(\aaa_1|\cdots|\aaa_n)$において,
その列ベクトルの並びは
$\lp(\aaa_j)<\lp(\aaa_{j+1})$で完全にきまる.
また, 列数がわかっていれば, 足りない分を零ベクトルとすればよいので,
零ベクトルではない列ベクトルの集合$\Set{\aaa_j|\aaa_j\neq \zzero_m}$
の情報から$A$は復元できる.
そこで, 
被役列階段行列$A=(\aaa_1|\cdots|\aaa_n)$と,
列ベクトルの集合$\Set{\aaa_j|\aaa_j\neq \zzero_m}$を同一視する.
この見方からは,
被役列階段行列とは,
次の条件を満たす$X\subset \RR^m\setminus\Set{\zzero_m}$である:
\begin{enumerate}
\item
  $\aaa\in X$はmonic.
\item
  $\aaa\in X\implies \aaa$は$X\setminus \Set{\aaa}$で簡約済み.
\end{enumerate}
行ベクトル表示された
被役行階段行列に関しても同様のことを考えることができる.
被役列階段行列と同様に,
被役行階段行列と条件を満たす零ベクトルではない行ベクトルの集合を同一視する.

行列に基本変形を行い
被役階段行列を得る手順を考えるため,
まずは,
次の計算手続きを考える:
\begin{algorithm}\makebox{}
\begin{description}
\item[Input]
数ベクトル$\aaa\in \KK^m$,
有限集合$X\subset\KK^m\setminus\Set{\zzero_m}$.
\item[Proceedure]\makebox{}
  \begin{enumerate}
  \item $a_i$を$(a_i)_{i\in I}=\aaa$で定義する.
  \item $a_{\lp(\bbb)}\neq 0$となる$\bbb\in X$がある間, 以下を繰り返す:
    \begin{enumerate}
    \item $\bbb\in X$が$a_{\lp(\bbb)}\neq 0$をみたすとする.
    \item $i_0$を$i_0=\lp(\bbb)$で定義する.
    \item $b_i$を$(b_i)_{i\in I}=\bbb$で定義する.
    \item $\ccc=(a_i)_{i\in I}-\frac{a_{i_0}}{b_{i_0}}(b_i)_{i\in I}$とする.
    \item $a_i$を$(a_i)_{i\in I}=\ccc$となるよう更新する.
    \end{enumerate}
  \item $(a_i)_{i\in I}$を出力し終了.
  \end{enumerate}
\end{description}
\end{algorithm}

$a_{\lp(\bbb)}\neq 0$となる$\bbb\in X$の選び方を指定していないので,
考えにくいものの,
この手続きは有限回のステップで必ず終了し数ベクトルを出力する.
その出力を$\reduce(\aaa,X)$で表すことにする.
$\reduce(\aaa,X)$は
$X$で簡約済みである.
また, その作り方から,
$\reduce(\aaa,X)=\aaa+\sum_{\bbb\in X}c_{\bbb} \bbb$
を満たす$c_{\bbb}\in\KK$が存在する.
\begin{remark}
  なおこの手続きのように,
  有限回のステップで必ず終了する手続きをアルゴリズムと呼ぶ.
\end{remark}
\begin{remark}
  \label{rem:reduce:proj}
  一般の有限集合$X\subset \KK^n$においては,
  $\lp(\bbb)=\lp(\bbb')$となる$\bbb,\bbb'\in X$が複数ある場合がある.
  その場合どちらを選ぶのかによって出力される数ベクトルが異なる可能性がある.
  $\bbb,\bbb'\in X,\lp(\bbb)=\lp(\bbb')\implies \bbb=\bbb'$を満たすときには,
  $\reduce(\aaa,X)$はその手順によらずただ一つに定まる.
  とくに,
  $X$が被役列階段行列であるとすると,
  $\aaa=(a_i)_{i\in I}\in \KK^m$に対し,
  \begin{align*}
    \reduce(\aaa,X)=\aaa-\sum_{\bbb\in X}a_{\lp(\bbb)}\bbb
  \end{align*}
  と閉じた式で書くことができる.
\end{remark}
$\aaa=(a_i)_{i\in I}\in \RR^m\setminus\Set{\zzero_{m}}$に対し,
$a_{\lp(\aaa)}\neq 0$であり, その逆数によるスカラー倍
\begin{align*}
  \frac{1}{a_{\lp(\aaa)}}\aaa
\end{align*}
はmonicである.
これを$\mono(\aaa)$と書く.

有限集合$X\subset\KK^m$を
基本変形で
被役階段行列にする方法は,
例えば,
$\reduce$, $\mono$を使って
以下のように書ける:
\begin{algorithm}\makebox{}
\begin{description}
\item[Input]
  有限集合$X\subset\KK^m$.
\item[Proceedure]\makebox{}
  \begin{enumerate}
  \item $X\setminus\Set{\bbb}$で簡約済みでない$\bbb\in X$が存在する間,
    以下を繰り返す:
    \begin{enumerate}
    \item $\bbb\in X$が$X\setminus\Set{\bbb}$で簡約済みでないとする.
    \item $X'=X\setminus\Set{\bbb}$とおく.
    \item $\aaa=\reduce(\bbb,X')$とおく.
    \item $X$を$X'\cup \Set{\aaa}$となるよう更新する.
    \end{enumerate}
  \item $\Set{\mono(\aaa)|\aaa\in X\setminus\Set{\zzero_m}}$を出力し終了.
  \end{enumerate}
\end{description}
\end{algorithm}
この手続きは有限回のステップで必ず終了し数ベクトルからなる有限集合を出力する.
その出力を$\reduce(X)$で表すことにする.
行列$A=(\aaa_1|\cdots|\aaa_n)$に対し,
$X=\Set{\aaa_1,\ldots,\aaa_n}$としたときの,
このアルゴリズムによる出力$\reduce(X)$を$\reduce_c(A)$と書くことにする.
$\reduce_c(A)$は,
$A$に列基本変形を行うことで得られる
被役列階段行列である.

$\reduce$, $\mono$で行った操作は行ベクトルに対しても同様に定義することができる.
行ベクトルに対する操作も同じ記号で書くことにする.
行列$A$の行ベクトル分解を考え,
その行ベクトルの集合$X$に対する$\reduce(X)$を
$\reduce_{r}(A)$と書く.
$\reduce_r(A)$は,
$A$に行基本変形を行うことで得られる
被役行階段行列である.

行列$A$の階数は,
基本変形によって得られる被役階段行列の非零なベクトルの総数であったので,
次のように計算できる:
$\#\reduce_r(A)=\#\reduce_c(A)=\rank(A)$,



\section{\Cref{chap:linspace:linmap}に関連すること}
\Cref{prop:linmap:kn:1,prop:linmap:kn:2}
より,
$\KK^n$から$\KK^m$への$\KK$-線形写像は,
$A\in \KK^{m\times n}$から作られる
\begin{align*}
  \shazo{\mu_A}{\KK^m}{\KK^n}{w}{Aw}
\end{align*}
を考えれば十分である.
とくに,
$\varphi(\ee^{(n)}_j)=\aaa_j$である$\KK$-線形写像は,
$A=(\aaa_1|\cdots|\aaa_n)$を使って,
$\mu_A$と書ける.
$\KK$が体であることから以下が成り立つ:
\begin{enumerate}
\item $\mu_A$が単射であることと$\rank(A)=n$は同値.
\item $\mu_A$が全射であることと$\rank(A)=m$は同値.
\end{enumerate}
したがって, $\mu_A$の全射性や単射性は,
$\reduce_r(A)$を計算することで調べることができる.
特に, 
$\mu_A$が同型写像であることと,
$A$が正則行列であることは同値であるが,
これらは,
$\rank(A)=n=m$は同値であるので,
これも$\reduce_r(A)$を計算することで調べることができる.
\begin{remark}
  $A$が正方行列であるとき,
  $A$が正則行列であることと,
  $\det(A)$が逆数をもつ, つまり$0$ではない
  ことは同値であるので,
  $A$の行列式を使っても$\mu_A$が同型写像かどうかを調べることができる.
\end{remark}

また,
写像の和, スカラー倍, 合成は以下のように行列の計算として計算できる:
\begin{align*}
  \mu_{A}+\mu_{A'}&=\mu_{A+A'}\\
  c\mu_{A}&=\mu_{cA}\\
  \mu_{A}\circ \mu_B&=\mu_{AB}.
\end{align*}

\section{\Cref{chap:subspace}に関連すること}

まず,
$A\in \KK^{m\times n}$から作られる線形写像
\begin{align*}
  \shazo{\mu_A}{\KK^m}{\KK^n}{w}{Aw}
\end{align*}
について考え,
これらの像と核を計算する方法を考える.

$\mu_A$の像は, $A=(\aaa_1|\cdots|\aaa_n)$と列ベクトル表示をすると,
定義から
\begin{align*}
  \Img(\mu_A)&=\Set{c_1\aaa_1+\cdots+c_n\aaa_n|c_1,\ldots,c_n\in \KK}\\
  &=\Braket{\aaa_1,\ldots,\aaa_n}_{\KK}
\end{align*}
である. したがって, アルゴリズムとして書くなら以下のようになる:
\begin{algorithm}\makebox{}
\begin{description}
\item[Input]
  行列$A\in\KK^{m\times n}$.
\item[Proceedure]\makebox{}
  \begin{enumerate}
  \item $(\aaa_1|\cdots|\aaa_n)=A$と列ベクトル分解する.
  \item $\Set{\aaa_1,\ldots,\aaa_n}$を出力し終了.
  \end{enumerate}
\end{description}
\end{algorithm}

$\mu_A$の核は,
定義から
\begin{align*}
  \Ker(\mu_A)=\Set{\aaa\in \KK^m |A\aaa=\zzero_n}
\end{align*}
である.
つまり,
$\xx$に関する方程式$A\xx=\zzero_n$の解空間である.
これは,
$A$から行基本変形で得られる被役行階段行列を計算することで,
求めることができる.
具体的には例えば次のように解くことができる:
\begin{algorithm}\makebox{}
\begin{description}
\item[Input]
  行列$A\in\KK^{m\times n}$.
\item[Proceedure]\makebox{}
  \begin{enumerate}
  \item $\bar A=\reduce_r(A)$とする.
  \item $J=\Set{1,\ldots,n}$とする.
  \item $\hat J=\Set{\lp(\aaa)|\aaa\in\bar  A }$とする. 
  \item $\check J=\Set{1,\ldots,n}\setminus \hat J$とする.
  \item $j\in \check J$に対し,
    以下を行う:
    \begin{enumerate}
    \item $\bbb_j$を次で定義する:
      \begin{align*}
        \bbb_j = \ee_j - \sum_{\aaa=(a_i)_{i\in J}\in\bar A}a_j \ee_{\lp(\aaa)}.
        \end{align*}
    \end{enumerate}
  \item $\Set{\bbb_j|j\in \check J}$を出力し終了.
  \end{enumerate}
\end{description}
\end{algorithm}
このアルゴリズムで得られる出力を$\Set{\bbb_{j_1},\ldots,\bbb_{j_{n-r}}}$とすると,
\begin{align*}
  \Set{c_1\bbb_{j_1}+\cdots+c_{n-r}\bbb_{j_{n-r}}|c_1,\ldots,c_{n-r}\in\KK}
=\Braket{\bbb_{j_1},\ldots,\bbb_{j_{n-r}}}_{\KK}
\end{align*}
は,
$\xx$に関する方程式$A\xx=\zzero_n$の解空間である.
つまり$\Ker(\mu_A)$である.


次に,
$\KK^m$の部分空間
\begin{align*}
  \Braket{\aaa_1,\ldots,\aaa_n}_{\KK}
  &=\Set{c_1\aaa_1+\cdots+c_n\aaa_n|c_1,\ldots,c_n\in \KK}\\
  \Braket{\bbb_1,\ldots,\bbb_l}_{\KK}
  &=\Set{c_1\bbb_1+\cdots+c_l\bbb_l|c_1,\ldots,c_l\in \KK}
\end{align*}
の和空間と共通部分を計算する方法について考える.

和空間は次を使えばわかる:
\begin{prop}
  $\aaa_1,\ldots,\aaa_n,\bbb_1,\ldots,\bbb_l\in\KK^m$に対し,
  \begin{align*}
    \Braket{\aaa_1,\ldots,\aaa_n}_{\KK}+\Braket{\bbb_1,\ldots,\bbb_l}_{\KK}
    =
    \Braket{\aaa_1,\ldots,\aaa_n,\bbb_1,\ldots,\bbb_l}_{\KK}.
  \end{align*}
\end{prop}
アルゴリズムとして書くなら以下のようになる:
\begin{algorithm}\makebox{}
\begin{description}
\item[Input]
  有限集合$A,B\subset \KK^m$
\item[Proceedure]\makebox{}
  \begin{enumerate}
    \item $A\cup B$を出力し終了.
  \end{enumerate}
\end{description}
\end{algorithm}

共通部分を計算するには, 次の補題を使う.
\begin{lemma}
  $U$を$\KK$-線形空間とし,
  $V,W$を$U$の部分空間とする.
  このとき,
  \begin{align*}
    \tilde V&=\Set{(v,-v)\in U\boxplus U|v\in V} \\
    \check W&=\Set{(w,0_U)\in U\boxplus U|w\in W} \\
    \hat U&=\Set{(0_U,u)\in U\boxplus U|u\in U}
  \end{align*}
  とおく.
  また,
  \begin{align*}
    \check X &= (\tilde V + \check W) \cap \hat U \\
    X&=\Set{x|(0_U,x) \in\check X}
  \end{align*}
  とする.
  このとき, $X=V\cap W$.
\end{lemma}
この補題により共通部分は以下のように計算できる.
\begin{prop}
  $\aaa_1,\ldots,\aaa_n,\bbb_1,\ldots,\bbb_l\in\KK^m$に対し,
  \begin{align*}
    X=\reduce(\Set{
    \begin{pmatrix}\aaa_1\\-\aaa_1\end{pmatrix},
      \ldots,
      \begin{pmatrix}\aaa_n\\-\aaa_n\end{pmatrix},
      \begin{pmatrix}\bbb_1\\\zzero_m\end{pmatrix},
      \ldots,
      \begin{pmatrix}\bbb_l\\\zzero_m\end{pmatrix}
})
  \end{align*}
  とし,
  \begin{align*}
    \check X=\Set{\begin{pmatrix}\aaa\\\bbb\end{pmatrix}\in X|\aaa=\zzero_m}
  \end{align*}
  とする.
  $\check X=\Set{\ccc_1,\ldots,\ccc_k}$
  とすると,
  \begin{align*}
    \Braket{\aaa_1,\ldots,\aaa_n}\cap \Braket{\bbb_1,\ldots,\bbb_l}=\Braket{\ccc_1,\ldots,\ccc_k}.
  \end{align*}
\end{prop}
アルゴリズムとして書くなら以下のようになる:
\begin{algorithm}\makebox{}
\begin{description}
\item[Input]
  有限集合$A,B\subset \KK^m$
\item[Proceedure]\makebox{}
  \begin{enumerate}
  \item
    $\tilde A=\Set{\begin{pmatrix}\aaa_1\\-\aaa_1\end{pmatrix},\ldots,\begin{pmatrix}\aaa_n\\-\aaa_n\end{pmatrix}}$
    とする.
  \item
    $\tilde B=\Set{\begin{pmatrix}\bbb_1\\\zzero_m\end{pmatrix},\ldots,\begin{pmatrix}\bbb_l\\\zzero_m\end{pmatrix}}$
    とする.
  \item $X=\reduce(\tilde A\cup \tilde B)$とする.
  \item $\check X=\Set{\begin{pmatrix}\aaa\\\bbb\end{pmatrix}\in \tilde X|\aaa=\zzero_m}$とする.
  \item $\Set{\bbb|\begin{pmatrix}\zzero_m\\\bbb\end{pmatrix}\in\check X}$を出力し終了.
  \end{enumerate}
\end{description}
\end{algorithm}

\section{\Cref{chap:basis}に関連すること}

まず, 一次独立性について考える.
与えられたベクトルの組が一次独立であるかを調べるには次を使う:
\begin{prop}
  $A=(\aaa_1|\cdots|\aaa_n)\in\KK^{m\times n}$に対して以下は同値:
  \begin{enumerate}
  \item $(\aaa_1,\ldots,\aaa_n)$は$\KK$上一次独立.
  \item $\rank(A)=n$.
  \end{enumerate}
\end{prop}
アルゴリズムとして書くなら以下のようになる:
\begin{algorithm}\makebox{}
\begin{description}
\item[Input]
  有限集合$A\subset \KK^m$
\item[Proceedure]\makebox{}
  \begin{enumerate}
  \item
    $\bar A=\reduce(A)$
    とする.
  \item
    $\# A= \#\bar A$なら次を行う:
    \begin{enumerate}
    \item \texttt{True}を出力し終了.
    \end{enumerate}
    そうでないなら次を行う:
    \begin{enumerate}
    \item \texttt{False}を出力し終了.
    \end{enumerate}
  \end{enumerate}
\end{description}
\end{algorithm}

次に,
生成系で与えられた部分空間について考える.
一般に次が成り立つ:
\begin{lemma}
  \label{lem:gen:inclusion}
  $U$を$\KK$線形空間とする.
  $v_1,\ldots,v_n,w_1,\ldots,w_m\in U$に対し,
  以下は同値:
  \begin{enumerate}
  \item $\Braket{v_1,\ldots,v_n}_{\KK}\subset\Braket{w_1,\ldots,w_m}_{\KK}$.
  \item $\Set{v_1,\ldots,v_n}_{\KK}\subset\Braket{w_1,\ldots,w_m}_{\KK}$.
  \end{enumerate}
\end{lemma}
したがって,
次が成り立つ:
\begin{lemma}
  $U$を$\KK$線形空間とする.
  $v_1,\ldots,v_n,w_1,\ldots,w_m\in U$に対し,
  以下は同値:
  \begin{enumerate}
  \item $\Braket{v_1,\ldots,v_n}_{\KK}=\Braket{w_1,\ldots,w_m}_{\KK}$.
  \item $\Set{v_1,\ldots,v_n}_{\KK}\subset\Braket{w_1,\ldots,w_m}_{\KK}$かつ
    $\Set{w_1,\ldots,w_m}_{\KK}\subset\Braket{v_1,\ldots,v_n}_{\KK}$.
  \end{enumerate}
\end{lemma}
また,
数ベクトル空間に対して次が成り立つ:
\begin{lemma}
  \label{lem:samespace:reducedech}
  $\aaa_1,\ldots,\aaa_n\in\KK^m$とする.
  $\aaa\in\KK^m$とし,
  $\bar\aaa=\reduce(\aaa,\Set{\aaa_1,\ldots,\aaa_n})$とする.
  このとき,
  \begin{align*}
    \Braket{\aaa,\aaa_1,\ldots,\aaa_n}_{\KK}
    =
    \Braket{\bar\aaa,\aaa_1,\ldots,\aaa_n}_{\KK}.
  \end{align*}
\end{lemma}
したがって, 次が得られる:
\begin{lemma}
  $\aaa_1,\ldots,\aaa_n\in\KK^m$とする.
  $\Set{\bbb_1,\ldots,\bbb_r}=\reduce(\Set{\aaa_1,\ldots,\aaa_n})$とする.
  このとき,
  \begin{align*}
    \Braket{\aaa_1,\ldots,\aaa_n}_{\KK}
    =
    \Braket{\bbb_1,\ldots,\bbb_r}_{\KK}.
  \end{align*}
\end{lemma}


また,
$\Set{\aaa_1,\ldots,\aaa_n}$は被役階段行列であるときに,
$\aaa\in\KK^m$が$\Braket{\aaa_1,\ldots,\aaa_n}$の元であるかどうかは,
次を使えば調べられる.
\begin{prop}
  \label{prop:subspace:belong:prob}
  $\aaa,\aaa_1,\ldots,\aaa_n\in\KK^m$とし,
  $\Set{\aaa_1,\ldots,\aaa_n}$は被役階段行列であるとする.
  このとき,
  以下は同値:
  \begin{enumerate}
  \item $\aaa\in\Braket{\aaa_1,\ldots,\aaa_n}_{\KK}$.
  \item $\reduce(\aaa,\Set{\aaa_1,\ldots,\aaa_n})=\zzero_m$.
  \end{enumerate}
\end{prop}
したがって,
生成系により与えられた部分空間に特定のベクトルが含まれるかどうかは,
は次のように調べればよい:
\begin{algorithm}\makebox{}
\begin{description}
\item[Input]
 $\aaa\in\KK^m$, 有限集合$A\subset \KK^m$
\item[Proceedure]\makebox{}
  \begin{enumerate}
  \item $\bar A=\reduce(A)$
  \item $\bar\aaa=\reduce(\aaa,\bar A)$とおく.
  \item $\bar\aaa=\zzero_m$ならば次を行う:
    \begin{enumerate}
    \item \texttt{True}を出力し終了.
    \end{enumerate}
  そうでないなら次を行う:
    \begin{enumerate}
    \item \texttt{False}を出力し終了.
    \end{enumerate}
  \end{enumerate}
\end{description}
\end{algorithm}
%% このアルゴリズムによる出力を$\iselement(\aaa,A)$と書くことにする.
%% $\iselement(\aaa,\Set{\aaa_1,\ldots,\aaa_n})$は,
%% $\aaa\in\Braket{\aaa_1,\ldots,\aaa_n}_{\KK}$なら\texttt{True},
%% そうでないなら\texttt{False}となる.

与えられた部分空間の包含関係を調べるには,
\Cref{lem:gen:inclusion}を利用し,
次のようにすれば良い:
\begin{algorithm}\makebox{}
\begin{description}
\item[Input]
 有限集合$A, B\subset \KK^m$ 
\item[Proceedure]\makebox{}
  \begin{enumerate}
  \item $\bar B=\reduce(B)$.
  \item $\aaa\in A$に対し, 以下を行う:
    \begin{enumerate}
    \item $\reduce(\aaa,\bar B)\neq\zzero_m$なら次を行う:
      \begin{enumerate}
      \item \texttt{False}を出力し終了.
      \end{enumerate}
    \end{enumerate}
  \item \texttt{True}を出力し終了.
  \end{enumerate}
\end{description}
\end{algorithm}
%% このアルゴリズムによる出力を$\issubspace(A,B)$と書くことにする.
%% $A=\Set{\aaa_1,\ldots,\aaa_n}$,
%% $B=\Set{\bbb_1,\ldots,\bbb_l}$に対し,
%% $\issubspace(A,B)$は,
%% $\Braket{\aaa_1,\ldots,\aaa_n}_{\KK}=\Braket{\bbb_1,\ldots,\bbb_l}_{\KK}$なら\texttt{True},
%% そうでないなら\texttt{False}となる.

与えられた部分空間が等しいかどうかは,
このアルゴリズムを用いて,
$\Set{\aaa_1,\ldots,\aaa_n}\subset \Braket{\bbb_1,\ldots,\bbb_l}$と
$\Braket{\aaa_1,\ldots,\aaa_n}\supset \Set{\bbb_1,\ldots,\bbb_l}$を
調べてもよいが,
\Cref{lem:samespace:reducedech}
被役列階段行列の唯一性により, 次で計算できる.
\begin{prop}
  \label{prop:reducedech:subspace:eq:criterion}
  $\aaa_1,\ldots,\aaa_n,\bbb_1,\ldots,\bbb_l\in\KK^m$に対し,
  以下は同値:
  \begin{enumerate}
  \item $\Braket{\aaa_1,\ldots,\aaa_n}_{\KK}=\Braket{\bbb_1,\ldots,\bbb_l}_{\KK}$.
  \item $\reduce(\Set{\aaa_1,\ldots,\aaa_r})=\reduce(\Set{\bbb_1,\ldots,\bbb_l})$.
  \end{enumerate}
\end{prop}
アルゴリズムとして書くなら以下のようになる:
\begin{algorithm}\makebox{}
\begin{description}
\item[Input]
  有限集合$A,B\subset \KK^m$
\item[Proceedure]\makebox{}
  \begin{enumerate}
  \item $\bar A=\reduce(A)$とおく.
  \item $\bar B=\reduce(B)$とおく.
  \item $\bar A=\bar B$ならば次を行う:
    \begin{enumerate}
    \item \texttt{True}を出力し終了.
    \end{enumerate}
  そうでないなら次を行う:
    \begin{enumerate}
    \item \texttt{False}を出力し終了.
    \end{enumerate}
  \end{enumerate}
\end{description}
\end{algorithm}


次に, 与えられた部分空間の基底を求める方法について考える.
\Cref{lem:samespace:reducedech}と
被役列階段行列の列ベクトルは一次独立であることから,
$\Set{\bbb_1,\ldots,\bbb_r}=\reduce(\Set{\aaa_1,\ldots,\aaa_n})$に対し,
$(\bbb_1,\ldots,\bbb_r)$は$\Braket{\aaa_1,\ldots,\aaa_n}_{\KK}$
の基底である.
したがって,
$\Braket{\aaa_1,\ldots,\aaa_n}_{\KK}$
の基底を何か一つ与えたいときには,
$\reduce(\Set{\aaa_1,\ldots,\aaa_n})$
を計算するだけで良い.
また, \Cref{prop:reducedech:subspace:eq:criterion,prop:subspace:belong:prob}などもあるので,
この基底は有用である.

一方,
一般には
$\reduce(A)\subset A$ではない.
与えられた生成系に含まれるベクトルを用いて基底を与えるには,
基底は極大な一次独立集合であることを用い,
次のように計算すればよい:
\begin{algorithm}\makebox{}
\begin{description}
\item[Input]
  有限集合$A\subset \KK^m$
\item[Proceedure]\makebox{}
  \begin{enumerate}
  \item $X=\Set{ \aaa\in A|\aaa\neq \zzero_m}$とおく.
  \item $B=\emptyset$とおく.
  \item $\bar B=\emptyset$とおく.
  \item $X\neq\emptyset$の間以下を行う:
    \begin{enumerate}
    \item $\bbb\in X$とする.
    \item $B$に$\bbb$を付け加える.
    \item $\bar B$を$\reduce(\bar B\cup \Set{\bbb})$となるよう更新する.
    \item $X$を$\Set{\aaa\in X| \reduce(\aaa,\bar B)\neq \zzero_m}$となるよう更新する.
    \end{enumerate}
  \item $B$を出力して終了.
  \end{enumerate}
\end{description}
\end{algorithm}
また,
すでに与えられている一次独立なベクトル達を延長して,
基底を得るためには以下のように計算すれば良い:
\begin{algorithm}\makebox{}
\begin{description}
\item[Input]
  有限集合$A\subset \KK^m$,
  有限集合$B\subset \Braket{A}_{\KK}$
\item[Proceedure]\makebox{}
  \begin{enumerate}
  \item $\bar B=\reduce(B)$とおく.
  \item $\#\bar B \neq \# B$なら, 次を行う:
    \begin{enumerate}
    \item エラー(与えられた$B$が一次独立ではない)として終了する.
    \end{enumerate}
  \item $X=\Set{ \aaa\in A|\reduce(\aaa,\bar B)\neq \zzero_m}$とおく.
  \item $X\neq\emptyset$の間以下を行う:
    \begin{enumerate}
    \item $\bbb\in X$とする.
    \item $B$に$\bbb$を付け加える.
    \item $\bar B$を$\reduce(\bar B\cup \Set{\bbb})$となるよう更新する.
    \item $X$を$\Set{\aaa\in X| \reduce(\aaa,\bar B)\neq \zzero_m}$となるよう更新する.
    \end{enumerate}
  \item $B$を出力して終了.
  \end{enumerate}
\end{description}
\end{algorithm}

\section{\Cref{chap:quotient}に関連すること}

$X\subset\KK^n$を被役列階段行列とする.
このとき, $\aaa\in\KK^n$に対し,
$\reduce(\aaa,X)$が閉じた式で書けることを
\Cref{rem:reduce:proj}では見た.
この表示から
\begin{align*}
  \shazo{\varphi}{\KK^m}{\KK^m}
        {\aaa}{\reduce(\aaa,X)}
\end{align*}
が$\KK$線形写像であることがすぐわかる.
また,
\begin{align*}
  \check I&=\Set{\lp(\bbb)|\bbb\in X},\\
  \hat I&=\Set{1,\ldots,m}\setminus\check I
\end{align*}
とし,
$\Set{j_1,\ldots,j_r}=\hat I$とおくと,
$\Img(\varphi)=\Braket{\ee_{j_1},\ldots,\ee_{j_r}}_{\KK}$である.
また, $\reduce(\ee_{j_k},X)=\ee_{j_k}$であるので,
$\varphi\circ\varphi=\varphi$である.


\Cref{prop:subspace:belong:prob}で見たように,
$\Set{\aaa_1,\ldots,\aaa_n}$は被役階段行列であるときに,
$\aaa\in\KK^m$が$\Braket{\aaa_1,\ldots,\aaa_n}$の元であるかどうかは,
$\reduce(\aaa,\Set{\aaa_1,\ldots,\aaa_n})$が$\zzero_m$であるかどうかを調べればよい.
さらに次のこともわかる:
\begin{prop}
  \label{prop:quotient:reduce}
  $\aaa_1,\ldots,\aaa_n\in\KK^m$とし,
  $\Set{\aaa_1,\ldots,\aaa_n}$は被役列階段行列であるとする.
  また, $V=\Braket{\aaa_1,\ldots,\aaa_n}_{\KK}$とおく.
  このとき,
  $\aaa,\bbb\in \KK^m$に対し,
  以下は同値:
  \begin{enumerate}
  \item $\aaa-\bbb\in V$.
  \item $[\aaa]_V=[\bbb]_V$.
  \item $\reduce(\aaa,\Set{\aaa_1,\ldots,\aaa_n})=\reduce(\bbb,\Set{\aaa_1,\ldots,\aaa_n})$.
  \end{enumerate}
\end{prop}
$A=\Set{\aaa_1,\ldots,\aaa_n}$は被役階段行列であり,
$V=\Braket{\aaa_1,\ldots,\aaa_n}_{\KK}$とする.
このとき,
\Cref{prop:quotient:reduce}があるので,
ベクトルが等しいかどうかは$A$で簡約済みのベクトルを比較すればよい.
また,
$\aaa\in\KK^n$に対し$\reduce(\aaa,X)$を対応させる写像が$\KK$-線形写像
であり$\varphi\circ\varphi=\varphi$であるので,
線型結合を考えるときは,
簡約済みのベクトルの線型結合を考えても,
線型結合考えてから簡約してもよいことがわかる.
さらに,
$\check I=\Set{\lp(\bbb)|\bbb\in X}$,
$\hat I=\Set{1,\ldots,m}\setminus\check I$とし,
$\Set{j_1,\ldots,j_r}=\hat I$とおくと,
$([\ee_{j_1}]_V,\ldots,[\ee_{j_r}]_V)$は,
$\KK^m/V$の基底である.



